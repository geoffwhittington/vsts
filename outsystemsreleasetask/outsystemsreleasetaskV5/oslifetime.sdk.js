"use strict";
/**
 * v1
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const request = require("request");
const Promise = require("bluebird");
let defaultBasePath = 'https://localhost/lifetimeapi/rest/v1';
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
/* tslint:disable:no-unused-variable */
/**
* Status of application in a given environment.
*/
class AppStatusInEnv {
}
exports.AppStatusInEnv = AppStatusInEnv;
/**
* An application with its details and its status in the environments were it is running.
*/
class Application {
}
exports.Application = Application;
/**
* A depoyment conflict.
*/
class ApplicationConflict {
}
exports.ApplicationConflict = ApplicationConflict;
/**
* Operation executed in the deployment over the application.
*/
class ApplicationOperation {
}
exports.ApplicationOperation = ApplicationOperation;
/**
* Information about a specific version of an application and the versions of its modules.
*/
class ApplicationVersion {
}
exports.ApplicationVersion = ApplicationVersion;
/**
* A structure holding the new version name for the application and for its native applications, if applicable.
*/
class ApplicationVersionCreate {
}
exports.ApplicationVersionCreate = ApplicationVersionCreate;
/**
*
*/
class ApplicationVersionKeyRecord {
}
exports.ApplicationVersionKeyRecord = ApplicationVersionKeyRecord;
/**
* Deployment information with the operations executed.
*/
class Deployment {
}
exports.Deployment = Deployment;
/**
*
*/
class DeploymentApplicationConflictsRecord {
}
exports.DeploymentApplicationConflictsRecord = DeploymentApplicationConflictsRecord;
/**
* Message from a deployment operation log.
*/
class DeploymentMessage {
}
exports.DeploymentMessage = DeploymentMessage;
/**
*
*/
class DeploymentStatusDeploymentLogRecord {
}
exports.DeploymentStatusDeploymentLogRecord = DeploymentStatusDeploymentLogRecord;
/**
* The link for the application binary file.
*/
class DownloadLink {
}
exports.DownloadLink = DownloadLink;
/**
* An environment and its information.
*/
class Environment {
}
exports.Environment = Environment;
/**
* Status of mobile application in a given environment.
*/
class MobileAppStatusInEnv {
}
exports.MobileAppStatusInEnv = MobileAppStatusInEnv;
/**
* A mobile version and its information.
*/
class MobileVersion {
}
exports.MobileVersion = MobileVersion;
/**
* Module information and the status in the environments where the modules are running.
*/
class Module {
}
exports.Module = Module;
/**
* A module conflict.
*/
class ModuleConflict {
}
exports.ModuleConflict = ModuleConflict;
/**
* Element version information, such as action, entity, structure, among others.
*/
class ModuleElement {
}
exports.ModuleElement = ModuleElement;
/**
* Status of module in a given environment.
*/
class ModuleStatusInEnv {
}
exports.ModuleStatusInEnv = ModuleStatusInEnv;
/**
* A module version and its information.
*/
class ModuleVersion {
}
exports.ModuleVersion = ModuleVersion;
/**
*
*/
class NotesSourceEnvironmentKeyTargetEnvironmentKeyApplicationVersionKeysRecord {
}
exports.NotesSourceEnvironmentKeyTargetEnvironmentKeyApplicationVersionKeysRecord = NotesSourceEnvironmentKeyTargetEnvironmentKeyApplicationVersionKeysRecord;
class HttpBasicAuth {
    applyToRequest(requestOptions) {
        requestOptions.auth = {
            username: this.username, password: this.password
        };
    }
}
exports.HttpBasicAuth = HttpBasicAuth;
class ApiKeyAuth {
    constructor(location, paramName) {
        this.location = location;
        this.paramName = paramName;
    }
    applyToRequest(requestOptions) {
        if (this.location == "query") {
            requestOptions.qs[this.paramName] = this.apiKey;
        }
        else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}
exports.ApiKeyAuth = ApiKeyAuth;
class OAuth {
    applyToRequest(requestOptions) {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}
exports.OAuth = OAuth;
class VoidAuth {
    applyToRequest(_) {
        // Do nothing
    }
}
exports.VoidAuth = VoidAuth;
var V1ApiApiKeys;
(function (V1ApiApiKeys) {
})(V1ApiApiKeys = exports.V1ApiApiKeys || (exports.V1ApiApiKeys = {}));
class V1Api {
    constructor(basePathOrUsername, password, basePath) {
        this.basePath = defaultBasePath;
        this.defaultHeaders = {
            'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJsaWZldGltZSIsInN1YiI6IllUWTFPVGs1T0RFdE5XWmtOUzAwWW1aa0xXSmhPR1F0TnpNd01EQmxaRFF5TXpsaCIsImF1ZCI6ImxpZmV0aW1lIiwiaWF0IjoiMTQ5NzIyMzc5OSIsImppdCI6InlNZkhaZnVMOHkifQ==.dmMX09hcZh3Hqa3oHFpFoZ9AZU2VjK35XArCgCCPaZ0='
        };
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    setApiKey(key, value) {
        this.authentications[V1ApiApiKeys[key]].apiKey = value;
    }
    /**
     *
     * Returns the details of a given application.
     * @param applicationKey The key of the desired application.
     * @param includeModules When set to true, the modules details are also retrieved. The default value is false.
     * @param includeEnvStatus When set to true, the application status per environment is also returned. The default value is false.
     */
    applicationsGet(applicationKey, includeModules, includeEnvStatus) {
        const localVarPath = this.basePath + '/applications/{ApplicationKey}/'
            .replace('{' + 'ApplicationKey' + '}', String(applicationKey));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'applicationKey' is not null or undefined
        if (applicationKey === null || applicationKey === undefined) {
            throw new Error('Required parameter applicationKey was null or undefined when calling applicationsGet.');
        }
        if (includeModules !== undefined) {
            queryParameters['IncludeModules'] = includeModules;
        }
        if (includeEnvStatus !== undefined) {
            queryParameters['IncludeEnvStatus'] = includeEnvStatus;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * Returns a list of applications that exist in the infrastructure.
     * @param includeModules When set to true, the modules are also returned. The default value is false.
     * @param includeEnvStatus When set to true, the application status per environment is also returned. The default value is false.
     */
    applicationsList(includeModules, includeEnvStatus) {
        const localVarPath = this.basePath + '/applications/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (includeModules !== undefined) {
            queryParameters['IncludeModules'] = includeModules;
        }
        if (includeEnvStatus !== undefined) {
            queryParameters['IncludeEnvStatus'] = includeEnvStatus;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * Returns the details of a given version of the specified application.
     * @param applicationKey The key of the application whose version is being requested.
     * @param versionKey The key of the desired application version.
     * @param includeModules When set to true, the modules details are also retrieved. The default value is false.
     */
    applicationsVersionsGet(applicationKey, versionKey, includeModules) {
        const localVarPath = this.basePath + '/applications/{ApplicationKey}/versions/{VersionKey}/'
            .replace('{' + 'ApplicationKey' + '}', String(applicationKey))
            .replace('{' + 'VersionKey' + '}', String(versionKey));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'applicationKey' is not null or undefined
        if (applicationKey === null || applicationKey === undefined) {
            throw new Error('Required parameter applicationKey was null or undefined when calling applicationsVersionsGet.');
        }
        // verify required parameter 'versionKey' is not null or undefined
        if (versionKey === null || versionKey === undefined) {
            throw new Error('Required parameter versionKey was null or undefined when calling applicationsVersionsGet.');
        }
        // verify required parameter 'includeModules' is not null or undefined
        if (includeModules === null || includeModules === undefined) {
            throw new Error('Required parameter includeModules was null or undefined when calling applicationsVersionsGet.');
        }
        if (includeModules !== undefined) {
            queryParameters['IncludeModules'] = includeModules;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * Returns a list of versions of a given application.
     * @param applicationKey The key of the desired application.
     * @param maximumVersionsToReturn The maximum number of versions to return. The default value is 5.
     */
    applicationsVersionsList(applicationKey, maximumVersionsToReturn) {
        const localVarPath = this.basePath + '/applications/{ApplicationKey}/versions/'
            .replace('{' + 'ApplicationKey' + '}', String(applicationKey));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'applicationKey' is not null or undefined
        if (applicationKey === null || applicationKey === undefined) {
            throw new Error('Required parameter applicationKey was null or undefined when calling applicationsVersionsList.');
        }
        if (maximumVersionsToReturn !== undefined) {
            queryParameters['MaximumVersionsToReturn'] = maximumVersionsToReturn;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * Creates a deployment to a target environment. An optional list of applications to include in the deployment can be specified. The input is a subset of deployment object.
     * @param deploymentData A Deployment record.
     */
    deploymentsCreate(deploymentData) {
        const localVarPath = this.basePath + '/deployments/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'deploymentData' is not null or undefined
        if (deploymentData === null || deploymentData === undefined) {
            throw new Error('Required parameter deploymentData was null or undefined when calling deploymentsCreate.');
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: deploymentData,
        };
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * Discards a deployment, if possible. Only deployments whose state is “saved” can be deleted.
     * @param deploymentKey The key of the deployment to delete.
     */
    deploymentsDelete(deploymentKey) {
        const localVarPath = this.basePath + '/deployments/{DeploymentKey}/'
            .replace('{' + 'DeploymentKey' + '}', String(deploymentKey));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'deploymentKey' is not null or undefined
        if (deploymentKey === null || deploymentKey === undefined) {
            throw new Error('Required parameter deploymentKey was null or undefined when calling deploymentsDelete.');
        }
        let useFormData = false;
        let requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * Executes the given command in a specified deployment. The allowed commands are “start”, “continue” and “abort”.
     * @param deploymentKey The key of the deployment where the command will be executed.
     * @param command The command to execute. One of “start”, “continue” or “abort”.
     */
    deploymentsExecuteCommand(deploymentKey, command) {
        const localVarPath = this.basePath + '/deployments/{DeploymentKey}/{Command}/'
            .replace('{' + 'DeploymentKey' + '}', String(deploymentKey))
            .replace('{' + 'Command' + '}', String(command));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'deploymentKey' is not null or undefined
        if (deploymentKey === null || deploymentKey === undefined) {
            throw new Error('Required parameter deploymentKey was null or undefined when calling deploymentsExecuteCommand.');
        }
        // verify required parameter 'command' is not null or undefined
        if (command === null || command === undefined) {
            throw new Error('Required parameter command was null or undefined when calling deploymentsExecuteCommand.');
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * Returns the details of a given deployment. The returned information contains the included applications and the possible conflicts that can arise from the deployment of the current applications.
     * @param deploymentKey The key of the desired deployment.
     */
    deploymentsGet(deploymentKey) {
        const localVarPath = this.basePath + '/deployments/{DeploymentKey}/'
            .replace('{' + 'DeploymentKey' + '}', String(deploymentKey));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'deploymentKey' is not null or undefined
        if (deploymentKey === null || deploymentKey === undefined) {
            throw new Error('Required parameter deploymentKey was null or undefined when calling deploymentsGet.');
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * Returns the details of a given deployment execution, including the deployment status and messages.
     * @param deploymentKey The key of the deployment whose status is being requested.
     */
    deploymentsGetStatus(deploymentKey) {
        const localVarPath = this.basePath + '/deployments/{DeploymentKey}/status/'
            .replace('{' + 'DeploymentKey' + '}', String(deploymentKey));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'deploymentKey' is not null or undefined
        if (deploymentKey === null || deploymentKey === undefined) {
            throw new Error('Required parameter deploymentKey was null or undefined when calling deploymentsGetStatus.');
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * Returns a list of deployments ordered by creation date, from newest to oldest.
     * @param minDate The minimum creation date of the deployments to return. The default value is 1 week before the current date.
     * @param maxDate The maximum creation date of the deployments to return. The default value is the current date.
     */
    deploymentsList(minDate, maxDate) {
        const localVarPath = this.basePath + '/deployments/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (minDate !== undefined) {
            queryParameters['MinDate'] = minDate;
        }
        if (maxDate !== undefined) {
            queryParameters['MaxDate'] = maxDate;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * Updates a given deployment. An optional list of applications to include in the deployment can be specified. The input is a subset of deployment object.
     * @param deploymentKey The key of the deployment to update.
     * @param deploymentData The deployment information to update.
     */
    deploymentsUpdate(deploymentKey, deploymentData) {
        const localVarPath = this.basePath + '/deployments/{DeploymentKey}/'
            .replace('{' + 'DeploymentKey' + '}', String(deploymentKey));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'deploymentKey' is not null or undefined
        if (deploymentKey === null || deploymentKey === undefined) {
            throw new Error('Required parameter deploymentKey was null or undefined when calling deploymentsUpdate.');
        }
        // verify required parameter 'deploymentData' is not null or undefined
        if (deploymentData === null || deploymentData === undefined) {
            throw new Error('Required parameter deploymentData was null or undefined when calling deploymentsUpdate.');
        }
        let useFormData = false;
        let requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: deploymentData,
        };
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @hide This is a method use only to actually download the files is not really an API method.
     * @param downloadKey
     */
    downloads(downloadKey) {
        const localVarPath = this.basePath + '/downloads/{DownloadKey}/'
            .replace('{' + 'DownloadKey' + '}', String(downloadKey));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'downloadKey' is not null or undefined
        if (downloadKey === null || downloadKey === undefined) {
            throw new Error('Required parameter downloadKey was null or undefined when calling downloads.');
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * Creates a new version of the application based on the current running application.
     * @param environmentKey The key of the environment from which to get the application.
     * @param applicationKey The key of the application for which to generate a new version.
     * @param applicationVersionCreate A structure holding the new version name for the application and for its native applications, if applicable.
     */
    environmentsApplicationsVersionsCreate(environmentKey, applicationKey, applicationVersionCreate) {
        const localVarPath = this.basePath + '/environments/{EnvironmentKey}/applications/{ApplicationKey}/versions/'
            .replace('{' + 'EnvironmentKey' + '}', String(environmentKey))
            .replace('{' + 'ApplicationKey' + '}', String(applicationKey));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling environmentsApplicationsVersionsCreate.');
        }
        // verify required parameter 'applicationKey' is not null or undefined
        if (applicationKey === null || applicationKey === undefined) {
            throw new Error('Required parameter applicationKey was null or undefined when calling environmentsApplicationsVersionsCreate.');
        }
        // verify required parameter 'applicationVersionCreate' is not null or undefined
        if (applicationVersionCreate === null || applicationVersionCreate === undefined) {
            throw new Error('Required parameter applicationVersionCreate was null or undefined when calling environmentsApplicationsVersionsCreate.');
        }
        let useFormData = false;
        let requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: applicationVersionCreate,
        };
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * Returns a link where the binary file for a given application can be downloaded. The link will expire in 60 minutes.
     * @param environmentKey The key of the environment from which to get the application binary file link.
     * @param applicationKey The key of the application for which to get the binary file link.
     * @param type The type of binary file to return, when applicable. One of “oap”, “apk” or “ipa”.
     */
    environmentsDownloadRunningApp(environmentKey, applicationKey, type) {
        const localVarPath = this.basePath + '/environments/{EnvironmentKey}/applications/{ApplicationKey}/content/'
            .replace('{' + 'EnvironmentKey' + '}', String(environmentKey))
            .replace('{' + 'ApplicationKey' + '}', String(applicationKey));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling environmentsDownloadRunningApp.');
        }
        // verify required parameter 'applicationKey' is not null or undefined
        if (applicationKey === null || applicationKey === undefined) {
            throw new Error('Required parameter applicationKey was null or undefined when calling environmentsDownloadRunningApp.');
        }
        if (type !== undefined) {
            queryParameters['Type'] = type;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * Returns the details of a given environment.
     * @param environmentKey The key of the desired environment.
     */
    environmentsGet(environmentKey) {
        const localVarPath = this.basePath + '/environments/{EnvironmentKey}/'
            .replace('{' + 'EnvironmentKey' + '}', String(environmentKey));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling environmentsGet.');
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * Returns information about the running version of the specified application in a given environment.
     * @param environmentKey The key of the environment from which to get the running application details.
     * @param applicationKey The key of the application whose details are being requested.
     * @param includeEnvStatus When set to true, the applications’ status information in the environment is included in the result. The default value is false.
     * @param includeModules When set to true, the modules details are also retrieved. The default value is false.
     */
    environmentsGetRunningApp(environmentKey, applicationKey, includeEnvStatus, includeModules) {
        const localVarPath = this.basePath + '/environments/{EnvironmentKey}/applications/{ApplicationKey}/'
            .replace('{' + 'EnvironmentKey' + '}', String(environmentKey))
            .replace('{' + 'ApplicationKey' + '}', String(applicationKey));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling environmentsGetRunningApp.');
        }
        // verify required parameter 'applicationKey' is not null or undefined
        if (applicationKey === null || applicationKey === undefined) {
            throw new Error('Required parameter applicationKey was null or undefined when calling environmentsGetRunningApp.');
        }
        if (includeEnvStatus !== undefined) {
            queryParameters['IncludeEnvStatus'] = includeEnvStatus;
        }
        if (includeModules !== undefined) {
            queryParameters['IncludeModules'] = includeModules;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * Returns information about the running versions of all applications in a given environment.
     * @param environmentKey The key of the environment whose list of running applications is being requested.
     * @param includeModules When set to true, the modules details are also retrieved. The default value is false.
     * @param includeEnvStatus When set to true, the applications’ status information in the environment is included in the result. The default value is false.
     */
    environmentsGetRunningApps(environmentKey, includeModules, includeEnvStatus) {
        const localVarPath = this.basePath + '/environments/{EnvironmentKey}/applications/'
            .replace('{' + 'EnvironmentKey' + '}', String(environmentKey));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling environmentsGetRunningApps.');
        }
        if (includeModules !== undefined) {
            queryParameters['IncludeModules'] = includeModules;
        }
        if (includeEnvStatus !== undefined) {
            queryParameters['IncludeEnvStatus'] = includeEnvStatus;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * Lists all the environments in the infrastructure.
     */
    environmentsList() {
        const localVarPath = this.basePath + '/environments/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * Returns the details of a given module version.
     * @param moduleKey The module from where to retrieve the versions from.
     * @param moduleVersionKey Key of the module version to return.
     * @param includePublicElements Boolean to indicate if public elements should be returned. Default is false.
     * @param includeConsumedElements Boolean to indicate if consumed elements should be returned. Default is false.
     */
    moduleVersionGet(moduleKey, moduleVersionKey, includePublicElements, includeConsumedElements) {
        const localVarPath = this.basePath + '/modules/{ModuleKey}/versions/{ModuleVersionKey}/'
            .replace('{' + 'ModuleKey' + '}', String(moduleKey))
            .replace('{' + 'ModuleVersionKey' + '}', String(moduleVersionKey));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'moduleKey' is not null or undefined
        if (moduleKey === null || moduleKey === undefined) {
            throw new Error('Required parameter moduleKey was null or undefined when calling moduleVersionGet.');
        }
        // verify required parameter 'moduleVersionKey' is not null or undefined
        if (moduleVersionKey === null || moduleVersionKey === undefined) {
            throw new Error('Required parameter moduleVersionKey was null or undefined when calling moduleVersionGet.');
        }
        if (includePublicElements !== undefined) {
            queryParameters['IncludePublicElements'] = includePublicElements;
        }
        if (includeConsumedElements !== undefined) {
            queryParameters['IncludeConsumedElements'] = includeConsumedElements;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * Returns a list of versions of a given module.
     * @param moduleKey The module from where to retrieve the versions from.
     * @param includePublicElements Boolean to indicate if public elements should be returned. Default is false.
     * @param includeConsumedElements Boolean to indicate if consumed elements should be returned. Default is false.
     * @param maximumVersionsToReturn Maximum number of versions to return. Default is 5.
     */
    moduleVersionsList(moduleKey, includePublicElements, includeConsumedElements, maximumVersionsToReturn) {
        const localVarPath = this.basePath + '/modules/{ModuleKey}/versions/'
            .replace('{' + 'ModuleKey' + '}', String(moduleKey));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'moduleKey' is not null or undefined
        if (moduleKey === null || moduleKey === undefined) {
            throw new Error('Required parameter moduleKey was null or undefined when calling moduleVersionsList.');
        }
        if (includePublicElements !== undefined) {
            queryParameters['IncludePublicElements'] = includePublicElements;
        }
        if (includeConsumedElements !== undefined) {
            queryParameters['IncludeConsumedElements'] = includeConsumedElements;
        }
        if (maximumVersionsToReturn !== undefined) {
            queryParameters['MaximumVersionsToReturn'] = maximumVersionsToReturn;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * Returns the details of a given module.
     * @param moduleKey Key of the module to list the details from.
     * @param includeEnvStatus When set to true, the module status per environment is also returned. The default value is false.
     */
    modulesGet(moduleKey, includeEnvStatus) {
        const localVarPath = this.basePath + '/modules/{ModuleKey}/'
            .replace('{' + 'ModuleKey' + '}', String(moduleKey));
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        // verify required parameter 'moduleKey' is not null or undefined
        if (moduleKey === null || moduleKey === undefined) {
            throw new Error('Required parameter moduleKey was null or undefined when calling modulesGet.');
        }
        if (includeEnvStatus !== undefined) {
            queryParameters['IncludeEnvStatus'] = includeEnvStatus;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * Returns a list of modules that exist in the infrastructure.
     * @param includeEnvStatus When set to true, the module status per environment is also returned. The default value is false.
     */
    modulesList(includeEnvStatus) {
        const localVarPath = this.basePath + '/modules/';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (includeEnvStatus !== undefined) {
            queryParameters['IncludeEnvStatus'] = includeEnvStatus;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.V1Api = V1Api;
