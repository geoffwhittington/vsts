/**
 * v1
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as request from "request"
import * as http from "http"
import * as bluebird from "bluebird"

let defaultBasePath = 'https://localhost/lifetimeapi/rest/v1';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */

/**
* Status of application in a given environment.
*/
export class AppStatusInEnv {
    /**
    * Environment unique identifier.
    */
    'environmentKey': string;
    /**
    * Base application version unique identifier. If app is not modified in environment, this is the application version deployed.
    */
    'baseApplicationVersionKey': string;
    /**
    * True if the application has been changed since the last tag, false otherwise.
    */
    'IsModified': boolean;
    /**
    * Indicates the application status.
    */
    'isModifiedReason': string;
    /**
    * Indicates the application status.
    */
    'isModifiedMessage': string;
    /**
    * Indicates the application consistency status.
    */
    'consistencyStatus': string;
    /**
    * Messages regarding the consistency status of the application.
    */
    'consistencyStatusMessages': string;
    /**
    * Status of mobile apps in environment.
    */
    'mobileAppsStatus': Array<MobileAppStatusInEnv>;
    /**
    * Status of modules in environment.
    */
    'ModuleStatusInEnvs': Array<ModuleStatusInEnv>;
}

/**
* An application with its details and its status in the environments were it is running.
*/
export class Application {
    /**
    * Application unique identifier.
    */
    'key': string;
    /**
    * Name of the application.
    */
    'Name': string;
    /**
    * Identifies the kind of application. [Mobile|WebResponsive]
    */
    'kind': string;
    /**
    * The team that owns the application.
    */
    'team': string;
    /**
    * Description of the application.
    */
    'description': string;
    /**
    * Relative URL path of the application, starting from the hostname.
    */
    'uRLPath': string;
    /**
    * Hash of the application icon. Can be used to detect changes in the application icon.
    */
    'iconHash': string;
    /**
    * The URL for the application icon.
    */
    'iconURL': string;
    /**
    * Indicates if the application is a built-in component of the AgilePlatform (e.g. ServiceCenter, LifeTime, ...).
    */
    'isSystem': boolean;
    /**
    * Information about the status of the application in each environment it is running.
    */
    'AppStatusInEnvs': Array<AppStatusInEnv>;
}

/**
* A depoyment conflict.
*/
export class ApplicationConflict {
    /**
    * Description of the conflict.
    */
    'message': string;
    'producerApplicationOperation': ApplicationOperation;
    'consumerApplicationOperation': ApplicationOperation;
    'moduleConflict': ModuleConflict;
}

/**
* Operation executed in the deployment over the application.
*/
export class ApplicationOperation {
    /**
    * Application unique identifier.
    */
    'applicationKey': string;
    /**
    * Application Version unique identifier.
    */
    'applicationVersionKey': string;
    /**
    * Label of the operation to be performed. Example: Deploy 1.5.
    */
    'deploymentOperation': string;
}

/**
* Information about a specific version of an application and the versions of its modules.
*/
export class ApplicationVersion {
    /**
    * Application version unique identifier.
    */
    'Key': string;
    /**
    * Application unique identifier.
    */
    'applicationKey': string;
    /**
    * Version of the application.
    */
    'Version': string;
    /**
    * List of mobile versions.
    */
    'mobileVersions': Array<MobileVersion>;
    /**
    * The primary color of the application interface.
    */
    'primaryColor': string;
    /**
    * The native has relative to the mobile platform.
    */
    'nativeHash': string;
    /**
    * List of module versions.
    */
    'moduleVersions': Array<ModuleVersion>;
}

/**
* A structure holding the new version name for the application and for its native applications, if applicable.
*/
export class ApplicationVersionCreate {
    /**
    * Change log of the version to be created.
    */
    'changeLog': string;
    /**
    * Version of the application.
    */
    'version': string;
    /**
    * List of mobile versions.
    */
    'mobileVersions': Array<MobileVersion>;
    /**
    * List of module version keys to validate if the current state of the application is still the expected.
    */
    'moduleVersionKeys': Array<string>;
}

/**
* 
*/
export class ApplicationVersionKeyRecord {
    /**
    * The key of the newly created application version.
    */
    'ApplicationVersionKey': string;
}

/**
* Deployment information with the operations executed.
*/
export class Deployment {
    /**
    * Deployment unique identifier.
    */
    'key': string;
    /**
    * Source environment unique identifier.
    */
    'sourceEnvironmentKey': string;
    /**
    * Target environment unique identifier.
    */
    'targetEnvironmentKey': string;
    /**
    * Deployment notes.
    */
    'notes': string;
    /**
    * Date and time when the deployment plan was created.
    */
    'createdOn': Date;
    /**
    * Name of the user who created the deployment plan.
    */
    'createdBy': string;
    /**
    * Username of the user who created the deployment plan.
    */
    'createdByUsername': string;
    /**
    * The date and time when the deployment plan was saved.
    */
    'savedOn': Date;
    /**
    * Name of the user who last saved the deployment plan.
    */
    'savedBy': string;
    /**
    * Username of the user who last saved the deployment plan.
    */
    'savedByUsername': string;
    /**
    * The date and time when the deployment started.
    */
    'startedOn': Date;
    /**
    * Name of the user who started the deployment.
    */
    'startedBy': string;
    /**
    * Username of the user who started the deployment.
    */
    'startedByUsername': string;
    /**
    * The date and time when the deployment was aborted.
    */
    'abortedOn': Date;
    /**
    * Name of the user who aborted the deployment.
    */
    'abortedBy': string;
    /**
    * Username of the user who aborted the deployment.
    */
    'abortedByUsername': string;
    /**
    * List of Application Versions included in the deployment.
    */
    'applicationsVersionKeys': Array<string>;
}

/**
* 
*/
export class DeploymentApplicationConflictsRecord {
    'deployment': Deployment;
    /**
    * List of conflicts between applications in the deployment.
    */
    'applicationConflicts': Array<ApplicationConflict>;
}

/**
* Message from a deployment operation log.
*/
export class DeploymentMessage {
    /**
    * Date and time when the message was logged.
    */
    'instant': Date;
    /**
    * Details of the message.
    */
    'Message': string;
}

/**
* 
*/
export class DeploymentStatusDeploymentLogRecord {
    /**
    * Status of the deployment. [saved | running | needs_user_intervention | aborted | aborting | finished_successful | finished_with_warnings | finished_with_errors]
    */
    'DeploymentStatus': string;
    /**
    * List of deployment messages.
    */
    'DeploymentLog': Array<DeploymentMessage>;
}

/**
* The link for the application binary file.
*/
export class DownloadLink {
    /**
    * The link for the application binary file. 
    */
    'url': string;
    /**
    * The expiration date and time of the returned link.
    */
    'expires': Date;
}

/**
* An environment and its information.
*/
export class Environment {
    /**
    * Unique identifier of the environment.
    */
    'key': string;
    /**
    * Name of the environment.
    */
    'name': string;
    /**
    * Platform Server version. [X.X.X.X]
    */
    'oSVersion': string;
    /**
    * The order of the environment as registered in Lifetime.
    */
    'order': number;
    /**
    * Hostname of the environment as registered.
    */
    'hostName': string;
    /**
    * Indicates if connections to the environment are made using HTTPS.
    */
    'useHTTPS': boolean;
    /**
    * Indicates the type of the environment. [Development | Test | Production]
    */
    'environmentType': string;
    /**
    * Number of front-end servers in the environment.
    */
    'numberOfFrontEnds': number;
    /**
    * Stack of the application server. [.NET | JAVA]
    */
    'applicationServerType': string;
    /**
    * Application server in use. [IIS | JBoss | WebLogic]
    */
    'applicationServer': string;
    /**
    * Type of database provider. [SqlServer | Oracle]
    */
    'databaseProvider': string;
    /**
    * Indicates if the environment is running on a cloud service.
    */
    'isCloudEnvironment': boolean;
}

/**
* Status of mobile application in a given environment.
*/
export class MobileAppStatusInEnv {
    /**
    * Environment unique identifier.
    */
    'environmentKey': string;
    /**
    * Name of native platform. [Android | iOS]
    */
    'nativePlatform': string;
    /**
    * The version number, like for example 1.5.4, of the native build. It is used to be able to map the version to the version in the Andoid or iOS store.
    */
    'versionNumber': string;
    /**
    * True if the binary of the application is available for the current configuration.
    */
    'hasBinaryAvailable': boolean;
    /**
    * True if the application is configured.
    */
    'isConfigured': boolean;
    /**
    * True if the configuration of the Mobile Application has changed in the environment.
    */
    'isConfigurationChanged': boolean;
    /**
    * True if the Native Hash of the Mobile Application does not match the one in the AppVersionNativeBuild baseline.
    */
    'isModified': boolean;
}

/**
* A mobile version and its information.
*/
export class MobileVersion {
    /**
    * Name of native platform. [Android | iOS]
    */
    'nativePlatform': string;
    /**
    * The version number, like for example 1.5.4, of the native build. It is used to be able to map the version to the version in the Andoid or iOS store.
    */
    'versionNumber': string;
    /**
    * The description of the mobile version.
    */
    'versionDescription': string;
}

/**
* Module information and the status in the environments where the modules are running.
*/
export class Module {
    /**
    * Module unique identifier.
    */
    'key': string;
    /**
    * Name of the module.
    */
    'name': string;
    /**
    * Description of the module.
    */
    'description': string;
    /**
    * Module type (eSpace or Extension).
    */
    'kind': string;
    /**
    * Status of the module in environments
    */
    'moduleStatusInEnv': Array<ModuleStatusInEnv>;
}

/**
* A module conflict.
*/
export class ModuleConflict {
    /**
    * Producer Module unique identifier.
    */
    'producerModuleKey': string;
    /**
    * Consumer Module unique identifier.
    */
    'consumerModuleKey': string;
    /**
    * Total number of required elements.
    */
    'totalRequiredElements': number;
    /**
    * Type of conflict. [Producer Module Missing|Producer Element Missing|Producer Element Incompatible|Consumer Module Outdated|Newer Producer Module Available|IncompatiblePlatformServer|ConsumerModuleMoved|ProducerModuleMoved|NameColision]
    */
    'conflictType': string;
}

/**
* Element version information, such as action, entity, structure, among others.
*/
export class ModuleElement {
    /**
    * Module element unique identifier.
    */
    'key': string;
    /**
    * Name of the element as specified by the developer.
    */
    'name': string;
    /**
    * Type of the element, such as action, entity, structure.
    */
    'elementType': string;
    /**
    * Hash of the element signature. Can be used to validate if the element version is compatible with another version, not producing a broken reference).
    */
    'compatibilitySignatureHash': string;
    /**
    * Hash of the element. Can be used to uniquely identify an element version.
    */
    'fullSignatureHash': string;
    /**
    * Unique identifier of the module where the element is publicly supplied, among others.
    */
    'moduleKey': string;
}

/**
* Status of module in a given environment.
*/
export class ModuleStatusInEnv {
    /**
    * Application unique identifier.
    */
    'applicationKey': string;
    /**
    * Environment unique identifier.
    */
    'environmentKey': string;
    /**
    * Module version unique identifier.
    */
    'ModuleVersionKey': string;
    /**
    * Indicates the module consistency status.
    */
    'consistencyStatus': string;
    /**
    * Messages regarding the consistency status of the module.
    */
    'consistencyStatusMessages': string;
}

/**
* A module version and its information.
*/
export class ModuleVersion {
    /**
    * Module version unique identifier.
    */
    'key': string;
    /**
    * Module unique identifier.
    */
    'moduleKey': string;
    /**
    * Date and time of the module version creation.
    */
    'createdOn': Date;
    /**
    * Name of the user that created the version.
    */
    'createdBy': string;
    /**
    * Username of the user that created the version.
    */
    'createdByUsername': string;
    /**
    * Non-unique hash of the module version. Can be used to validate if two module versions have semantic differences.
    */
    'generalHash': string;
    /**
    * If this module version is the result of a direct upgrade of another version, then this field contains the key of that version
    */
    'directUpgradeFromHash': string;
    /**
    * List of module elements exposed by module version.
    */
    'publicElements': Array<ModuleElement>;
    /**
    * List of module elements consumed by module version.
    */
    'consumedElements': Array<ModuleElement>;
}

/**
* 
*/
export class NotesSourceEnvironmentKeyTargetEnvironmentKeyApplicationVersionKeysRecord {
    /**
    * Deployment notes.
    */
    'notes': string;
    /**
    * Source environment unique identifier.
    */
    'sourceEnvironmentKey': string;
    /**
    * Target environment unique identifier.
    */
    'targetEnvironmentKey': string;
    /**
    * List of Application Versions included in the deployment.
    */
    'applicationVersionKeys': Array<string>;
}


export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: request.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string;

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: request.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string;
    public apiKey: string;

    // constructor(private paramName: string) {
    //     this.accessToken = paramName; 
    // }

    applyToRequest(requestOptions: request.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.apiKey;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(_: request.Options): void {
        // Do nothing
    }
}

export enum V1ApiApiKeys {
    os_auth
}

export class V1Api {
    protected basePath = defaultBasePath;
    protected defaultHeaders: any = {};
    protected _useQuerystring: boolean = false;

    protected authentications = {
        'default': new VoidAuth(),
        'os_auth': new OAuth()
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: V1ApiApiKeys, value: string) {
        this.authentications[V1ApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.os_auth.accessToken = token;
    }
    /**
     * 
     * Returns the details of a given application.
     * @param applicationKey The key of the desired application.
     * @param includeModules When set to true, the modules details are also retrieved. The default value is false.
     * @param includeEnvStatus When set to true, the application status per environment is also returned. The default value is false.
     */
    public applicationsGet(applicationKey: string, includeModules?: boolean, includeEnvStatus?: boolean): Promise<{ response: http.ClientResponse; body: Application; }> {
        const localVarPath = this.basePath + '/applications/{ApplicationKey}/'
            .replace('{' + 'ApplicationKey' + '}', String(applicationKey));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'applicationKey' is not null or undefined
        if (applicationKey === null || applicationKey === undefined) {
            throw new Error('Required parameter applicationKey was null or undefined when calling applicationsGet.');
        }

        if (includeModules !== undefined) {
            queryParameters['IncludeModules'] = includeModules;
        }

        if (includeEnvStatus !== undefined) {
            queryParameters['IncludeEnvStatus'] = includeEnvStatus;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);
        this.authentications.os_auth.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Application; }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns a list of applications that exist in the infrastructure.
     * @param includeModules When set to true, the modules are also returned. The default value is false.
     * @param includeEnvStatus When set to true, the application status per environment is also returned. The default value is false.
     */
    public applicationsList(includeModules?: boolean, includeEnvStatus?: boolean): Promise<{ response: http.ClientResponse; body: Array<Application>; }> {
        const localVarPath = this.basePath + '/applications/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (includeModules !== undefined) {
            queryParameters['IncludeModules'] = includeModules;
        }

        if (includeEnvStatus !== undefined) {
            queryParameters['IncludeEnvStatus'] = includeEnvStatus;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);
        this.authentications.os_auth.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Application>; }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns the details of a given version of the specified application.
     * @param applicationKey The key of the application whose version is being requested.
     * @param versionKey The key of the desired application version.
     * @param includeModules When set to true, the modules details are also retrieved. The default value is false.
     */
    public applicationsVersionsGet(applicationKey: string, versionKey: string, includeModules: boolean): Promise<{ response: http.ClientResponse; body: ApplicationVersion; }> {
        const localVarPath = this.basePath + '/applications/{ApplicationKey}/versions/{VersionKey}/'
            .replace('{' + 'ApplicationKey' + '}', String(applicationKey))
            .replace('{' + 'VersionKey' + '}', String(versionKey));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'applicationKey' is not null or undefined
        if (applicationKey === null || applicationKey === undefined) {
            throw new Error('Required parameter applicationKey was null or undefined when calling applicationsVersionsGet.');
        }

        // verify required parameter 'versionKey' is not null or undefined
        if (versionKey === null || versionKey === undefined) {
            throw new Error('Required parameter versionKey was null or undefined when calling applicationsVersionsGet.');
        }

        // verify required parameter 'includeModules' is not null or undefined
        if (includeModules === null || includeModules === undefined) {
            throw new Error('Required parameter includeModules was null or undefined when calling applicationsVersionsGet.');
        }

        if (includeModules !== undefined) {
            queryParameters['IncludeModules'] = includeModules;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);
        this.authentications.os_auth.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApplicationVersion; }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns a list of versions of a given application.
     * @param applicationKey The key of the desired application.
     * @param maximumVersionsToReturn The maximum number of versions to return. The default value is 5.
     */
    public applicationsVersionsList(applicationKey: string, maximumVersionsToReturn?: number): Promise<{ response: http.ClientResponse; body: Array<ApplicationVersion>; }> {
        const localVarPath = this.basePath + '/applications/{ApplicationKey}/versions/'
            .replace('{' + 'ApplicationKey' + '}', String(applicationKey));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'applicationKey' is not null or undefined
        if (applicationKey === null || applicationKey === undefined) {
            throw new Error('Required parameter applicationKey was null or undefined when calling applicationsVersionsList.');
        }

        if (maximumVersionsToReturn !== undefined) {
            queryParameters['MaximumVersionsToReturn'] = maximumVersionsToReturn;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);
        this.authentications.os_auth.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<ApplicationVersion>; }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Creates a deployment to a target environment. An optional list of applications to include in the deployment can be specified. The input is a subset of deployment object.
     * @param deploymentData A Deployment record.
     */
    public deploymentsCreate(deploymentData: NotesSourceEnvironmentKeyTargetEnvironmentKeyApplicationVersionKeysRecord): Promise<{ response: http.ClientResponse; body: string; }> {
        const localVarPath = this.basePath + '/deployments/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'deploymentData' is not null or undefined
        if (deploymentData === null || deploymentData === undefined) {
            throw new Error('Required parameter deploymentData was null or undefined when calling deploymentsCreate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: deploymentData,
        };

        this.authentications.default.applyToRequest(requestOptions);
        this.authentications.os_auth.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string; }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Discards a deployment, if possible. Only deployments whose state is “saved” can be deleted.
     * @param deploymentKey The key of the deployment to delete.
     */
    public deploymentsDelete(deploymentKey: string): Promise<{ response: http.ClientResponse; body?: any; }> {
        const localVarPath = this.basePath + '/deployments/{DeploymentKey}/'
            .replace('{' + 'DeploymentKey' + '}', String(deploymentKey));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'deploymentKey' is not null or undefined
        if (deploymentKey === null || deploymentKey === undefined) {
            throw new Error('Required parameter deploymentKey was null or undefined when calling deploymentsDelete.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);
        this.authentications.os_auth.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any; }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Executes the given command in a specified deployment. The allowed commands are “start”, “continue” and “abort”.
     * @param deploymentKey The key of the deployment where the command will be executed.
     * @param command The command to execute. One of “start”, “continue” or “abort”. 
     */
    public deploymentsExecuteCommand(deploymentKey: string, command: string): Promise<{ response: http.ClientResponse; body?: any; }> {
        const localVarPath = this.basePath + '/deployments/{DeploymentKey}/{Command}/'
            .replace('{' + 'DeploymentKey' + '}', String(deploymentKey))
            .replace('{' + 'Command' + '}', String(command));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'deploymentKey' is not null or undefined
        if (deploymentKey === null || deploymentKey === undefined) {
            throw new Error('Required parameter deploymentKey was null or undefined when calling deploymentsExecuteCommand.');
        }

        // verify required parameter 'command' is not null or undefined
        if (command === null || command === undefined) {
            throw new Error('Required parameter command was null or undefined when calling deploymentsExecuteCommand.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);
        this.authentications.os_auth.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any; }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns the details of a given deployment. The returned information contains the included applications and the possible conflicts that can arise from the deployment of the current applications.
     * @param deploymentKey The key of the desired deployment.
     */
    public deploymentsGet(deploymentKey: string): Promise<{ response: http.ClientResponse; body: DeploymentApplicationConflictsRecord; }> {
        const localVarPath = this.basePath + '/deployments/{DeploymentKey}/'
            .replace('{' + 'DeploymentKey' + '}', String(deploymentKey));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'deploymentKey' is not null or undefined
        if (deploymentKey === null || deploymentKey === undefined) {
            throw new Error('Required parameter deploymentKey was null or undefined when calling deploymentsGet.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);
        this.authentications.os_auth.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DeploymentApplicationConflictsRecord; }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns the details of a given deployment execution, including the deployment status and messages.
     * @param deploymentKey The key of the deployment whose status is being requested.
     */
    public deploymentsGetStatus(deploymentKey: string): Promise<{ response: http.ClientResponse; body: DeploymentStatusDeploymentLogRecord; }> {
        const localVarPath = this.basePath + '/deployments/{DeploymentKey}/status/'
            .replace('{' + 'DeploymentKey' + '}', String(deploymentKey));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'deploymentKey' is not null or undefined
        if (deploymentKey === null || deploymentKey === undefined) {
            throw new Error('Required parameter deploymentKey was null or undefined when calling deploymentsGetStatus.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);
        this.authentications.os_auth.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DeploymentStatusDeploymentLogRecord; }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns a list of deployments ordered by creation date, from newest to oldest.
     * @param minDate The minimum creation date of the deployments to return. The default value is 1 week before the current date.
     * @param maxDate The maximum creation date of the deployments to return. The default value is the current date.
     */
    public deploymentsList(minDate?: Date, maxDate?: Date): Promise<{ response: http.ClientResponse; body: Array<Deployment>; }> {
        const localVarPath = this.basePath + '/deployments/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (minDate !== undefined) {
            queryParameters['MinDate'] = minDate;
        }

        if (maxDate !== undefined) {
            queryParameters['MaxDate'] = maxDate;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);
        this.authentications.os_auth.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Deployment>; }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Updates a given deployment. An optional list of applications to include in the deployment can be specified. The input is a subset of deployment object.
     * @param deploymentKey The key of the deployment to update.
     * @param deploymentData The deployment information to update.
     */
    public deploymentsUpdate(deploymentKey: string, deploymentData: NotesSourceEnvironmentKeyTargetEnvironmentKeyApplicationVersionKeysRecord): Promise<{ response: http.ClientResponse; body: Deployment; }> {
        const localVarPath = this.basePath + '/deployments/{DeploymentKey}/'
            .replace('{' + 'DeploymentKey' + '}', String(deploymentKey));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'deploymentKey' is not null or undefined
        if (deploymentKey === null || deploymentKey === undefined) {
            throw new Error('Required parameter deploymentKey was null or undefined when calling deploymentsUpdate.');
        }

        // verify required parameter 'deploymentData' is not null or undefined
        if (deploymentData === null || deploymentData === undefined) {
            throw new Error('Required parameter deploymentData was null or undefined when calling deploymentsUpdate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: deploymentData,
        };

        this.authentications.default.applyToRequest(requestOptions);
        this.authentications.os_auth.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Deployment; }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @hide This is a method use only to actually download the files is not really an API method.
     * @param downloadKey 
     */
    public downloads(downloadKey: string): Promise<{ response: http.ClientResponse; body: string; }> {
        const localVarPath = this.basePath + '/downloads/{DownloadKey}/'
            .replace('{' + 'DownloadKey' + '}', String(downloadKey));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'downloadKey' is not null or undefined
        if (downloadKey === null || downloadKey === undefined) {
            throw new Error('Required parameter downloadKey was null or undefined when calling downloads.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);
        this.authentications.os_auth.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string; }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Creates a new version of the application based on the current running application.
     * @param environmentKey The key of the environment from which to get the application.
     * @param applicationKey The key of the application for which to generate a new version.
     * @param applicationVersionCreate A structure holding the new version name for the application and for its native applications, if applicable.
     */
    public environmentsApplicationsVersionsCreate(environmentKey: string, applicationKey: string, applicationVersionCreate: ApplicationVersionCreate): Promise<{ response: http.ClientResponse; body: ApplicationVersionKeyRecord; }> {
        const localVarPath = this.basePath + '/environments/{EnvironmentKey}/applications/{ApplicationKey}/versions/'
            .replace('{' + 'EnvironmentKey' + '}', String(environmentKey))
            .replace('{' + 'ApplicationKey' + '}', String(applicationKey));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling environmentsApplicationsVersionsCreate.');
        }

        // verify required parameter 'applicationKey' is not null or undefined
        if (applicationKey === null || applicationKey === undefined) {
            throw new Error('Required parameter applicationKey was null or undefined when calling environmentsApplicationsVersionsCreate.');
        }

        // verify required parameter 'applicationVersionCreate' is not null or undefined
        if (applicationVersionCreate === null || applicationVersionCreate === undefined) {
            throw new Error('Required parameter applicationVersionCreate was null or undefined when calling environmentsApplicationsVersionsCreate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: applicationVersionCreate,
        };

        this.authentications.default.applyToRequest(requestOptions);
        this.authentications.os_auth.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApplicationVersionKeyRecord; }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns a link where the binary file for a given application can be downloaded. The link will expire in 60 minutes.
     * @param environmentKey The key of the environment from which to get the application binary file link.
     * @param applicationKey The key of the application for which to get the binary file link.
     * @param type The type of binary file to return, when applicable. One of “oap”, “apk” or “ipa”.
     */
    public environmentsDownloadRunningApp(environmentKey: string, applicationKey: string, type?: string): Promise<{ response: http.ClientResponse; body: DownloadLink; }> {
        const localVarPath = this.basePath + '/environments/{EnvironmentKey}/applications/{ApplicationKey}/content/'
            .replace('{' + 'EnvironmentKey' + '}', String(environmentKey))
            .replace('{' + 'ApplicationKey' + '}', String(applicationKey));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling environmentsDownloadRunningApp.');
        }

        // verify required parameter 'applicationKey' is not null or undefined
        if (applicationKey === null || applicationKey === undefined) {
            throw new Error('Required parameter applicationKey was null or undefined when calling environmentsDownloadRunningApp.');
        }

        if (type !== undefined) {
            queryParameters['Type'] = type;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);
        this.authentications.os_auth.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DownloadLink; }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns the details of a given environment.
     * @param environmentKey The key of the desired environment.
     */
    public environmentsGet(environmentKey: string): Promise<{ response: http.ClientResponse; body: Environment; }> {
        const localVarPath = this.basePath + '/environments/{EnvironmentKey}/'
            .replace('{' + 'EnvironmentKey' + '}', String(environmentKey));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling environmentsGet.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);
        this.authentications.os_auth.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Environment; }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns information about the running version of the specified application in a given environment.
     * @param environmentKey The key of the environment from which to get the running application details.
     * @param applicationKey The key of the application whose details are being requested.
     * @param includeEnvStatus When set to true, the applications’ status information in the environment is included in the result. The default value is false.
     * @param includeModules When set to true, the modules details are also retrieved. The default value is false.
     */
    public environmentsGetRunningApp(environmentKey: string, applicationKey: string, includeEnvStatus?: boolean, includeModules?: boolean): Promise<{ response: http.ClientResponse; body: Application; }> {
        const localVarPath = this.basePath + '/environments/{EnvironmentKey}/applications/{ApplicationKey}/'
            .replace('{' + 'EnvironmentKey' + '}', String(environmentKey))
            .replace('{' + 'ApplicationKey' + '}', String(applicationKey));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling environmentsGetRunningApp.');
        }

        // verify required parameter 'applicationKey' is not null or undefined
        if (applicationKey === null || applicationKey === undefined) {
            throw new Error('Required parameter applicationKey was null or undefined when calling environmentsGetRunningApp.');
        }

        if (includeEnvStatus !== undefined) {
            queryParameters['IncludeEnvStatus'] = includeEnvStatus;
        }

        if (includeModules !== undefined) {
            queryParameters['IncludeModules'] = includeModules;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);
        this.authentications.os_auth.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Application; }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns information about the running versions of all applications in a given environment.
     * @param environmentKey The key of the environment whose list of running applications is being requested.
     * @param includeModules When set to true, the modules details are also retrieved. The default value is false.
     * @param includeEnvStatus When set to true, the applications’ status information in the environment is included in the result. The default value is false.
     */
    public environmentsGetRunningApps(environmentKey: string, includeModules?: boolean, includeEnvStatus?: boolean): Promise<{ response: http.ClientResponse; body: Array<Application>; }> {
        const localVarPath = this.basePath + '/environments/{EnvironmentKey}/applications/'
            .replace('{' + 'EnvironmentKey' + '}', String(environmentKey));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'environmentKey' is not null or undefined
        if (environmentKey === null || environmentKey === undefined) {
            throw new Error('Required parameter environmentKey was null or undefined when calling environmentsGetRunningApps.');
        }

        if (includeModules !== undefined) {
            queryParameters['IncludeModules'] = includeModules;
        }

        if (includeEnvStatus !== undefined) {
            queryParameters['IncludeEnvStatus'] = includeEnvStatus;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);
        this.authentications.os_auth.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Application>; }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Lists all the environments in the infrastructure.
     */
    public environmentsList(): Promise<{ response: http.ClientResponse; body: Array<Environment>; }> {
        const localVarPath = this.basePath + '/environments/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);
        this.authentications.os_auth.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Environment>; }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns the details of a given module version.
     * @param moduleKey The module from where to retrieve the versions from.
     * @param moduleVersionKey Key of the module version to return.
     * @param includePublicElements Boolean to indicate if public elements should be returned. Default is false.
     * @param includeConsumedElements Boolean to indicate if consumed elements should be returned. Default is false.
     */
    public moduleVersionGet(moduleKey: string, moduleVersionKey: string, includePublicElements?: boolean, includeConsumedElements?: boolean): Promise<{ response: http.ClientResponse; body: ModuleVersion; }> {
        const localVarPath = this.basePath + '/modules/{ModuleKey}/versions/{ModuleVersionKey}/'
            .replace('{' + 'ModuleKey' + '}', String(moduleKey))
            .replace('{' + 'ModuleVersionKey' + '}', String(moduleVersionKey));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'moduleKey' is not null or undefined
        if (moduleKey === null || moduleKey === undefined) {
            throw new Error('Required parameter moduleKey was null or undefined when calling moduleVersionGet.');
        }

        // verify required parameter 'moduleVersionKey' is not null or undefined
        if (moduleVersionKey === null || moduleVersionKey === undefined) {
            throw new Error('Required parameter moduleVersionKey was null or undefined when calling moduleVersionGet.');
        }

        if (includePublicElements !== undefined) {
            queryParameters['IncludePublicElements'] = includePublicElements;
        }

        if (includeConsumedElements !== undefined) {
            queryParameters['IncludeConsumedElements'] = includeConsumedElements;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);
        this.authentications.os_auth.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ModuleVersion; }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns a list of versions of a given module.
     * @param moduleKey The module from where to retrieve the versions from.
     * @param includePublicElements Boolean to indicate if public elements should be returned. Default is false.
     * @param includeConsumedElements Boolean to indicate if consumed elements should be returned. Default is false.
     * @param maximumVersionsToReturn Maximum number of versions to return. Default is 5.
     */
    public moduleVersionsList(moduleKey: string, includePublicElements?: boolean, includeConsumedElements?: boolean, maximumVersionsToReturn?: number): Promise<{ response: http.ClientResponse; body: Array<ModuleVersion>; }> {
        const localVarPath = this.basePath + '/modules/{ModuleKey}/versions/'
            .replace('{' + 'ModuleKey' + '}', String(moduleKey));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'moduleKey' is not null or undefined
        if (moduleKey === null || moduleKey === undefined) {
            throw new Error('Required parameter moduleKey was null or undefined when calling moduleVersionsList.');
        }

        if (includePublicElements !== undefined) {
            queryParameters['IncludePublicElements'] = includePublicElements;
        }

        if (includeConsumedElements !== undefined) {
            queryParameters['IncludeConsumedElements'] = includeConsumedElements;
        }

        if (maximumVersionsToReturn !== undefined) {
            queryParameters['MaximumVersionsToReturn'] = maximumVersionsToReturn;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);
        this.authentications.os_auth.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<ModuleVersion>; }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns the details of a given module.
     * @param moduleKey Key of the module to list the details from.
     * @param includeEnvStatus When set to true, the module status per environment is also returned. The default value is false.
     */
    public modulesGet(moduleKey: string, includeEnvStatus?: boolean): Promise<{ response: http.ClientResponse; body: Module; }> {
        const localVarPath = this.basePath + '/modules/{ModuleKey}/'
            .replace('{' + 'ModuleKey' + '}', String(moduleKey));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'moduleKey' is not null or undefined
        if (moduleKey === null || moduleKey === undefined) {
            throw new Error('Required parameter moduleKey was null or undefined when calling modulesGet.');
        }

        if (includeEnvStatus !== undefined) {
            queryParameters['IncludeEnvStatus'] = includeEnvStatus;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);
        this.authentications.os_auth.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Module; }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns a list of modules that exist in the infrastructure.
     * @param includeEnvStatus When set to true, the module status per environment is also returned. The default value is false.
     */
    public modulesList(includeEnvStatus?: boolean): Promise<{ response: http.ClientResponse; body: Array<Module>; }> {
        const localVarPath = this.basePath + '/modules/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (includeEnvStatus !== undefined) {
            queryParameters['IncludeEnvStatus'] = includeEnvStatus;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);
        this.authentications.os_auth.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Module>; }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
